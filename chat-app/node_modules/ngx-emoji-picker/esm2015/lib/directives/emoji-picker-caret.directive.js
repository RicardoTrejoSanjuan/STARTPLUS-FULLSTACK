/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Output, EventEmitter, ElementRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, distinctUntilChanged } from 'rxjs/operators';
import { CaretEvent } from '../misc/caret-event';
export class EmojiPickerCaretDirective {
    /**
     * @param {?} _el
     */
    constructor(_el) {
        this._el = _el;
        this.caretEmitter = new EventEmitter();
        this._caretEvent$ = new Subject();
        this._destroyed$ = new Subject();
        this._lastCaretEvent = CaretEvent.generateNullEvent();
        this._caretEvent$
            .pipe(takeUntil(this._destroyed$), distinctUntilChanged((event1, event2) => {
            return CaretEvent.compare(event1, event2);
        }))
            .subscribe((event) => {
            this.caretEmitter.emit(event);
            this._lastCaretEvent = event.clone();
        });
    }
    /**
     * @return {?}
     */
    get doc() {
        if (!this._doc) {
            this._doc = this._el.nativeElement.ownerDocument || this._el.nativeElement.document || document;
        }
        return this._doc;
    }
    /**
     * @return {?}
     */
    get win() {
        if (!this._win) {
            this._win = this.doc.defaultView || this.doc.parentWindow || window;
        }
        return this._win;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this._el.nativeElement.getAttribute('contenteditable') && this._el.nativeElement.tagName.toLowerCase() !== 'input') {
            throw new Error('(emojiPickerPositionEmitter) should only work on contenteditable enabled or input elements');
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyed$.next(true);
    }
    /**
     * @return {?}
     */
    updateCaretPosition() {
        /** @type {?} */
        const cEvent = CaretEvent.generateCaretEvent(this.win, this.doc, this._el.nativeElement);
        this._caretEvent$.next(cEvent);
    }
    /**
     * @return {?}
     */
    updateCaretDueMutation() {
        /** @type {?} */
        const cEvent = CaretEvent.generateCaretEvent(this.win, this.doc, this._el.nativeElement);
        /** @type {?} */
        let textMovement = cEvent.textContent.length - this._lastCaretEvent.textContent.length;
        cEvent.caretOffset = this._lastCaretEvent.caretOffset + textMovement;
        /** change detection after DOMSubtreeModified event is weird
         * ChangeDetectorRef.detectChanges(), ChangeDetectorRef.markForCheck(), ApplicationRef.tick(), NgZone.run()
         * all of those methods did not work as expected.
         * As a temporary hack I am emitting an event after a short timeout, which is fine due to the _caretEvent$ smart stream
         */
        setTimeout(() => {
            this._caretEvent$.next(cEvent);
        });
    }
}
EmojiPickerCaretDirective.decorators = [
    { type: Directive, args: [{
                selector: '[emojiPickerCaretEmitter]',
                host: {
                    '(keyup)': 'updateCaretPosition()',
                    '(mouseup)': 'updateCaretPosition()',
                    '(selectstart)': 'updateCaretPosition()',
                    '(focus)': 'updateCaretPosition()',
                    '(DOMSubtreeModified)': 'updateCaretDueMutation($event)'
                }
            },] }
];
/** @nocollapse */
EmojiPickerCaretDirective.ctorParameters = () => [
    { type: ElementRef }
];
EmojiPickerCaretDirective.propDecorators = {
    caretEmitter: [{ type: Output, args: ['emojiPickerCaretEmitter',] }]
};
if (false) {
    /** @type {?} */
    EmojiPickerCaretDirective.prototype.caretEmitter;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._caretEvent$;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._destroyed$;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._lastCaretEvent;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._win;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._doc;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._el;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1vamktcGlja2VyLWNhcmV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1lbW9qaS1waWNrZXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9lbW9qaS1waWNrZXItY2FyZXQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFvQixNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUtqRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFZakQsTUFBTSxPQUFPLHlCQUF5Qjs7OztJQTJCcEMsWUFDVSxHQUFlO1FBQWYsUUFBRyxHQUFILEdBQUcsQ0FBWTtRQTNCVSxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFFekUsaUJBQVksR0FBRyxJQUFJLE9BQU8sRUFBYyxDQUFDO1FBQ3pDLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUVyQyxvQkFBZSxHQUFlLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBd0JuRSxJQUFJLENBQUMsWUFBWTthQUNkLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLG9CQUFvQixDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3pFLE9BQU8sVUFBVSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUM7YUFDRixTQUFTLENBQUMsQ0FBQyxLQUFpQixFQUFFLEVBQUU7WUFDL0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUE7UUFDdEMsQ0FBQyxDQUFDLENBQ0g7SUFDSCxDQUFDOzs7O0lBNUJELElBQUksR0FBRztRQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQztTQUNqRztRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDOzs7O0lBRUQsSUFBSSxHQUFHO1FBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDZCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxJQUFJLE1BQU0sQ0FBQTtTQUNwRTtRQUVELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQTtJQUNsQixDQUFDOzs7O0lBZ0JELFFBQVE7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxLQUFLLE9BQU8sRUFBRTtZQUN2SCxNQUFNLElBQUksS0FBSyxDQUFDLDRGQUE0RixDQUFDLENBQUM7U0FDL0c7SUFDSCxDQUFDOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7Ozs7SUFFRCxtQkFBbUI7O2NBQ1gsTUFBTSxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7UUFDeEYsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakMsQ0FBQzs7OztJQUVELHNCQUFzQjs7Y0FDZCxNQUFNLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQzs7WUFDcEYsWUFBWSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLE1BQU07UUFDdEYsTUFBTSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsR0FBRyxZQUFZLENBQUM7UUFFckU7Ozs7V0FJRztRQUVGLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDZCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7OztZQWhGRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDJCQUEyQjtnQkFDckMsSUFBSSxFQUFFO29CQUNKLFNBQVMsRUFBRSx1QkFBdUI7b0JBQ2xDLFdBQVcsRUFBRSx1QkFBdUI7b0JBQ3BDLGVBQWUsRUFBRSx1QkFBdUI7b0JBQ3hDLFNBQVMsRUFBRSx1QkFBdUI7b0JBQ2xDLHNCQUFzQixFQUFFLGdDQUFnQztpQkFDekQ7YUFDRjs7OztZQWxCeUMsVUFBVTs7OzJCQW9CakQsTUFBTSxTQUFDLHlCQUF5Qjs7OztJQUFqQyxpREFBaUY7Ozs7O0lBRWpGLGlEQUFpRDs7Ozs7SUFDakQsZ0RBQTZDOzs7OztJQUU3QyxvREFBcUU7Ozs7O0lBRXJFLHlDQUFhOzs7OztJQUNiLHlDQUFhOzs7OztJQW1CWCx3Q0FBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBPbkluaXQsIE9uRGVzdHJveX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5cblxuXG5pbXBvcnQgeyBDYXJldEV2ZW50IH0gZnJvbSAnLi4vbWlzYy9jYXJldC1ldmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbW9qaVBpY2tlckNhcmV0RW1pdHRlcl0nLFxuICBob3N0OiB7XG4gICAgJyhrZXl1cCknOiAndXBkYXRlQ2FyZXRQb3NpdGlvbigpJyxcbiAgICAnKG1vdXNldXApJzogJ3VwZGF0ZUNhcmV0UG9zaXRpb24oKScsXG4gICAgJyhzZWxlY3RzdGFydCknOiAndXBkYXRlQ2FyZXRQb3NpdGlvbigpJyxcbiAgICAnKGZvY3VzKSc6ICd1cGRhdGVDYXJldFBvc2l0aW9uKCknLFxuICAgICcoRE9NU3VidHJlZU1vZGlmaWVkKSc6ICd1cGRhdGVDYXJldER1ZU11dGF0aW9uKCRldmVudCknXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgRW1vamlQaWNrZXJDYXJldERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgQE91dHB1dCgnZW1vamlQaWNrZXJDYXJldEVtaXR0ZXInKSBjYXJldEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPENhcmV0RXZlbnQ+KCk7XG5cbiAgcHJpdmF0ZSBfY2FyZXRFdmVudCQgPSBuZXcgU3ViamVjdDxDYXJldEV2ZW50PigpO1xuICBwcml2YXRlIF9kZXN0cm95ZWQkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBwcml2YXRlIF9sYXN0Q2FyZXRFdmVudDogQ2FyZXRFdmVudCA9IENhcmV0RXZlbnQuZ2VuZXJhdGVOdWxsRXZlbnQoKTtcblxuICBwcml2YXRlIF93aW47XG4gIHByaXZhdGUgX2RvYztcblxuICBnZXQgZG9jKCkge1xuICAgIGlmICghdGhpcy5fZG9jKSB7XG4gICAgICB0aGlzLl9kb2MgPSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgdGhpcy5fZWwubmF0aXZlRWxlbWVudC5kb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZG9jO1xuICB9XG5cbiAgZ2V0IHdpbigpIHtcbiAgICBpZiAoIXRoaXMuX3dpbikge1xuICAgICAgdGhpcy5fd2luID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2MucGFyZW50V2luZG93IHx8IHdpbmRvd1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93aW5cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2VsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHRoaXMuX2NhcmV0RXZlbnQkXG4gICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkJCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKChldmVudDEsIGV2ZW50MikgPT4ge1xuICAgICAgICByZXR1cm4gQ2FyZXRFdmVudC5jb21wYXJlKGV2ZW50MSwgZXZlbnQyKTtcbiAgICAgIH0pKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IENhcmV0RXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jYXJldEVtaXR0ZXIuZW1pdChldmVudCk7XG4gICAgICAgIHRoaXMuX2xhc3RDYXJldEV2ZW50ID0gZXZlbnQuY2xvbmUoKVxuICAgICAgfSlcbiAgICA7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAmJiB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2lucHV0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCcoZW1vamlQaWNrZXJQb3NpdGlvbkVtaXR0ZXIpIHNob3VsZCBvbmx5IHdvcmsgb24gY29udGVudGVkaXRhYmxlIGVuYWJsZWQgb3IgaW5wdXQgZWxlbWVudHMnKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQkLm5leHQodHJ1ZSk7XG4gIH1cblxuICB1cGRhdGVDYXJldFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGNFdmVudCA9IENhcmV0RXZlbnQuZ2VuZXJhdGVDYXJldEV2ZW50KHRoaXMud2luLCB0aGlzLmRvYywgdGhpcy5fZWwubmF0aXZlRWxlbWVudCk7XG4gICAgdGhpcy5fY2FyZXRFdmVudCQubmV4dChjRXZlbnQpO1xuICB9XG5cbiAgdXBkYXRlQ2FyZXREdWVNdXRhdGlvbigpIHtcbiAgICBjb25zdCBjRXZlbnQgPSBDYXJldEV2ZW50LmdlbmVyYXRlQ2FyZXRFdmVudCh0aGlzLndpbiwgdGhpcy5kb2MsIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIGxldCB0ZXh0TW92ZW1lbnQgPSBjRXZlbnQudGV4dENvbnRlbnQubGVuZ3RoIC0gdGhpcy5fbGFzdENhcmV0RXZlbnQudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIGNFdmVudC5jYXJldE9mZnNldCA9IHRoaXMuX2xhc3RDYXJldEV2ZW50LmNhcmV0T2Zmc2V0ICsgdGV4dE1vdmVtZW50O1xuXG4gICAgLyoqIGNoYW5nZSBkZXRlY3Rpb24gYWZ0ZXIgRE9NU3VidHJlZU1vZGlmaWVkIGV2ZW50IGlzIHdlaXJkXG4gICAgICogQ2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpLCBDaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKSwgQXBwbGljYXRpb25SZWYudGljaygpLCBOZ1pvbmUucnVuKClcbiAgICAgKiBhbGwgb2YgdGhvc2UgbWV0aG9kcyBkaWQgbm90IHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICogQXMgYSB0ZW1wb3JhcnkgaGFjayBJIGFtIGVtaXR0aW5nIGFuIGV2ZW50IGFmdGVyIGEgc2hvcnQgdGltZW91dCwgd2hpY2ggaXMgZmluZSBkdWUgdG8gdGhlIF9jYXJldEV2ZW50JCBzbWFydCBzdHJlYW1cbiAgICAgKi9cblxuICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICB0aGlzLl9jYXJldEV2ZW50JC5uZXh0KGNFdmVudCk7XG4gICAgIH0pO1xuICB9XG59XG4iXX0=