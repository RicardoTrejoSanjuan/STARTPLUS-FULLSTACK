/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Output, EventEmitter, ElementRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, distinctUntilChanged } from 'rxjs/operators';
import { CaretEvent } from '../misc/caret-event';
var EmojiPickerCaretDirective = /** @class */ (function () {
    function EmojiPickerCaretDirective(_el) {
        var _this = this;
        this._el = _el;
        this.caretEmitter = new EventEmitter();
        this._caretEvent$ = new Subject();
        this._destroyed$ = new Subject();
        this._lastCaretEvent = CaretEvent.generateNullEvent();
        this._caretEvent$
            .pipe(takeUntil(this._destroyed$), distinctUntilChanged(function (event1, event2) {
            return CaretEvent.compare(event1, event2);
        }))
            .subscribe(function (event) {
            _this.caretEmitter.emit(event);
            _this._lastCaretEvent = event.clone();
        });
    }
    Object.defineProperty(EmojiPickerCaretDirective.prototype, "doc", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this._doc) {
                this._doc = this._el.nativeElement.ownerDocument || this._el.nativeElement.document || document;
            }
            return this._doc;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmojiPickerCaretDirective.prototype, "win", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this._win) {
                this._win = this.doc.defaultView || this.doc.parentWindow || window;
            }
            return this._win;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    EmojiPickerCaretDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this._el.nativeElement.getAttribute('contenteditable') && this._el.nativeElement.tagName.toLowerCase() !== 'input') {
            throw new Error('(emojiPickerPositionEmitter) should only work on contenteditable enabled or input elements');
        }
    };
    /**
     * @return {?}
     */
    EmojiPickerCaretDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyed$.next(true);
    };
    /**
     * @return {?}
     */
    EmojiPickerCaretDirective.prototype.updateCaretPosition = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var cEvent = CaretEvent.generateCaretEvent(this.win, this.doc, this._el.nativeElement);
        this._caretEvent$.next(cEvent);
    };
    /**
     * @return {?}
     */
    EmojiPickerCaretDirective.prototype.updateCaretDueMutation = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var cEvent = CaretEvent.generateCaretEvent(this.win, this.doc, this._el.nativeElement);
        /** @type {?} */
        var textMovement = cEvent.textContent.length - this._lastCaretEvent.textContent.length;
        cEvent.caretOffset = this._lastCaretEvent.caretOffset + textMovement;
        /** change detection after DOMSubtreeModified event is weird
         * ChangeDetectorRef.detectChanges(), ChangeDetectorRef.markForCheck(), ApplicationRef.tick(), NgZone.run()
         * all of those methods did not work as expected.
         * As a temporary hack I am emitting an event after a short timeout, which is fine due to the _caretEvent$ smart stream
         */
        setTimeout(function () {
            _this._caretEvent$.next(cEvent);
        });
    };
    EmojiPickerCaretDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[emojiPickerCaretEmitter]',
                    host: {
                        '(keyup)': 'updateCaretPosition()',
                        '(mouseup)': 'updateCaretPosition()',
                        '(selectstart)': 'updateCaretPosition()',
                        '(focus)': 'updateCaretPosition()',
                        '(DOMSubtreeModified)': 'updateCaretDueMutation($event)'
                    }
                },] }
    ];
    /** @nocollapse */
    EmojiPickerCaretDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    EmojiPickerCaretDirective.propDecorators = {
        caretEmitter: [{ type: Output, args: ['emojiPickerCaretEmitter',] }]
    };
    return EmojiPickerCaretDirective;
}());
export { EmojiPickerCaretDirective };
if (false) {
    /** @type {?} */
    EmojiPickerCaretDirective.prototype.caretEmitter;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._caretEvent$;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._destroyed$;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._lastCaretEvent;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._win;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._doc;
    /**
     * @type {?}
     * @private
     */
    EmojiPickerCaretDirective.prototype._el;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1vamktcGlja2VyLWNhcmV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1lbW9qaS1waWNrZXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9lbW9qaS1waWNrZXItY2FyZXQuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFvQixNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUtqRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFakQ7SUFxQ0UsbUNBQ1UsR0FBZTtRQUR6QixpQkFZQztRQVhTLFFBQUcsR0FBSCxHQUFHLENBQVk7UUEzQlUsaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO1FBRXpFLGlCQUFZLEdBQUcsSUFBSSxPQUFPLEVBQWMsQ0FBQztRQUN6QyxnQkFBVyxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFFckMsb0JBQWUsR0FBZSxVQUFVLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQXdCbkUsSUFBSSxDQUFDLFlBQVk7YUFDZCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxvQkFBb0IsQ0FBQyxVQUFDLE1BQU0sRUFBRSxNQUFNO1lBQ3JFLE9BQU8sVUFBVSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQUM7YUFDRixTQUFTLENBQUMsVUFBQyxLQUFpQjtZQUMzQixLQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QixLQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQyxL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IERpcmVjdGl2ZSwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uSW5pdCwgT25EZXN0cm95fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cblxuXG5cbmltcG9ydCB7IENhcmV0RXZlbnQgfSBmcm9tICcuLi9taXNjL2NhcmV0LWV2ZW50JztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2Vtb2ppUGlja2VyQ2FyZXRFbWl0dGVyXScsXG4gIGhvc3Q6IHtcbiAgICAnKGtleXVwKSc6ICd1cGRhdGVDYXJldFBvc2l0aW9uKCknLFxuICAgICcobW91c2V1cCknOiAndXBkYXRlQ2FyZXRQb3NpdGlvbigpJyxcbiAgICAnKHNlbGVjdHN0YXJ0KSc6ICd1cGRhdGVDYXJldFBvc2l0aW9uKCknLFxuICAgICcoZm9jdXMpJzogJ3VwZGF0ZUNhcmV0UG9zaXRpb24oKScsXG4gICAgJyhET01TdWJ0cmVlTW9kaWZpZWQpJzogJ3VwZGF0ZUNhcmV0RHVlTXV0YXRpb24oJGV2ZW50KSdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBFbW9qaVBpY2tlckNhcmV0RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBAT3V0cHV0KCdlbW9qaVBpY2tlckNhcmV0RW1pdHRlcicpIGNhcmV0RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXI8Q2FyZXRFdmVudD4oKTtcblxuICBwcml2YXRlIF9jYXJldEV2ZW50JCA9IG5ldyBTdWJqZWN0PENhcmV0RXZlbnQ+KCk7XG4gIHByaXZhdGUgX2Rlc3Ryb3llZCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIHByaXZhdGUgX2xhc3RDYXJldEV2ZW50OiBDYXJldEV2ZW50ID0gQ2FyZXRFdmVudC5nZW5lcmF0ZU51bGxFdmVudCgpO1xuXG4gIHByaXZhdGUgX3dpbjtcbiAgcHJpdmF0ZSBfZG9jO1xuXG4gIGdldCBkb2MoKSB7XG4gICAgaWYgKCF0aGlzLl9kb2MpIHtcbiAgICAgIHRoaXMuX2RvYyA9IHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQub3duZXJEb2N1bWVudCB8fCB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LmRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kb2M7XG4gIH1cblxuICBnZXQgd2luKCkge1xuICAgIGlmICghdGhpcy5fd2luKSB7XG4gICAgICB0aGlzLl93aW4gPSB0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dpblxuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgdGhpcy5fY2FyZXRFdmVudCRcbiAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQkKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKGV2ZW50MSwgZXZlbnQyKSA9PiB7XG4gICAgICAgIHJldHVybiBDYXJldEV2ZW50LmNvbXBhcmUoZXZlbnQxLCBldmVudDIpO1xuICAgICAgfSkpXG4gICAgICAuc3Vic2NyaWJlKChldmVudDogQ2FyZXRFdmVudCkgPT4ge1xuICAgICAgICB0aGlzLmNhcmV0RW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgICAgICAgdGhpcy5fbGFzdENhcmV0RXZlbnQgPSBldmVudC5jbG9uZSgpXG4gICAgICB9KVxuICAgIDtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy5fZWwubmF0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpICYmIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaW5wdXQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyhlbW9qaVBpY2tlclBvc2l0aW9uRW1pdHRlcikgc2hvdWxkIG9ubHkgd29yayBvbiBjb250ZW50ZWRpdGFibGUgZW5hYmxlZCBvciBpbnB1dCBlbGVtZW50cycpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3llZCQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIHVwZGF0ZUNhcmV0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgY0V2ZW50ID0gQ2FyZXRFdmVudC5nZW5lcmF0ZUNhcmV0RXZlbnQodGhpcy53aW4sIHRoaXMuZG9jLCB0aGlzLl9lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB0aGlzLl9jYXJldEV2ZW50JC5uZXh0KGNFdmVudCk7XG4gIH1cblxuICB1cGRhdGVDYXJldER1ZU11dGF0aW9uKCkge1xuICAgIGNvbnN0IGNFdmVudCA9IENhcmV0RXZlbnQuZ2VuZXJhdGVDYXJldEV2ZW50KHRoaXMud2luLCB0aGlzLmRvYywgdGhpcy5fZWwubmF0aXZlRWxlbWVudCk7XG4gICAgbGV0IHRleHRNb3ZlbWVudCA9IGNFdmVudC50ZXh0Q29udGVudC5sZW5ndGggLSB0aGlzLl9sYXN0Q2FyZXRFdmVudC50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgY0V2ZW50LmNhcmV0T2Zmc2V0ID0gdGhpcy5fbGFzdENhcmV0RXZlbnQuY2FyZXRPZmZzZXQgKyB0ZXh0TW92ZW1lbnQ7XG5cbiAgICAvKiogY2hhbmdlIGRldGVjdGlvbiBhZnRlciBET01TdWJ0cmVlTW9kaWZpZWQgZXZlbnQgaXMgd2VpcmRcbiAgICAgKiBDaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCksIENoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpLCBBcHBsaWNhdGlvblJlZi50aWNrKCksIE5nWm9uZS5ydW4oKVxuICAgICAqIGFsbCBvZiB0aG9zZSBtZXRob2RzIGRpZCBub3Qgd29yayBhcyBleHBlY3RlZC5cbiAgICAgKiBBcyBhIHRlbXBvcmFyeSBoYWNrIEkgYW0gZW1pdHRpbmcgYW4gZXZlbnQgYWZ0ZXIgYSBzaG9ydCB0aW1lb3V0LCB3aGljaCBpcyBmaW5lIGR1ZSB0byB0aGUgX2NhcmV0RXZlbnQkIHNtYXJ0IHN0cmVhbVxuICAgICAqL1xuXG4gICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgIHRoaXMuX2NhcmV0RXZlbnQkLm5leHQoY0V2ZW50KTtcbiAgICAgfSk7XG4gIH1cbn1cbiJdfQ==